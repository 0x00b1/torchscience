// src/torchscience/csrc/optix/context.h
// OptiX device context, module, pipeline, and SBT management
#pragma once

#ifdef TORCHSCIENCE_OPTIX

#include <cuda.h>
#include <cuda_runtime.h>
#include <optix.h>
#include <optix_function_table_definition.h>
#include <optix_stubs.h>

#include <cstring>
#include <mutex>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

#include "destroy_callback.h"
#include "launch_params.h"

// Embedded PTX (generated by cmake at build time)
#include "torchscience_optix_programs_ptx.h"

namespace torchscience::optix {

#define OPTIX_CHECK(call)                                                     \
  do {                                                                        \
    OptixResult res = call;                                                   \
    if (res != OPTIX_SUCCESS) {                                               \
      TORCH_CHECK(false, "OptiX error: ", optixGetErrorName(res), " (",       \
                  optixGetErrorString(res), ") in " #call);                   \
    }                                                                         \
  } while (0)

#define CUDA_CHECK(call)                                                      \
  do {                                                                        \
    cudaError_t err = call;                                                   \
    if (err != cudaSuccess) {                                                 \
      TORCH_CHECK(false, "CUDA error: ", cudaGetErrorString(err),             \
                  " in " #call);                                              \
    }                                                                         \
  } while (0)

// Resources associated with a built GAS (geometry acceleration structure)
struct GASResources {
  CUdeviceptr d_gas_output = 0;
  size_t gas_output_size = 0;
  OptixTraversableHandle traversable = 0;
};

// Singleton OptiX context with pipeline and SBT
class OptiXContext {
 public:
  static OptiXContext& instance() {
    static OptiXContext ctx;
    return ctx;
  }

  OptixDeviceContext context() const { return context_; }
  OptixPipeline pipeline() const { return pipeline_; }
  const OptixShaderBindingTable& sbt() const { return sbt_; }

  // Scene registry
  int64_t register_gas(GASResources resources) {
    std::lock_guard<std::mutex> lock(registry_mutex_);
    int64_t handle = next_handle_++;
    scenes_[handle] = resources;
    return handle;
  }

  GASResources get_gas(int64_t handle) const {
    std::lock_guard<std::mutex> lock(registry_mutex_);
    auto it = scenes_.find(handle);
    TORCH_CHECK(it != scenes_.end(),
                "OptiX: invalid scene handle ", handle);
    return it->second;
  }

  void unregister_gas(int64_t handle) {
    std::lock_guard<std::mutex> lock(registry_mutex_);
    auto it = scenes_.find(handle);
    if (it != scenes_.end()) {
      if (it->second.d_gas_output) {
        cudaFree(reinterpret_cast<void*>(it->second.d_gas_output));
      }
      scenes_.erase(it);
    }
  }

 private:
  OptiXContext() { initialize(); }

  ~OptiXContext() {
    // Clean up remaining scenes
    for (auto& [handle, res] : scenes_) {
      if (res.d_gas_output) {
        cudaFree(reinterpret_cast<void*>(res.d_gas_output));
      }
    }
    scenes_.clear();

    // Clean up SBT device buffers
    if (d_raygen_record_) cudaFree(reinterpret_cast<void*>(d_raygen_record_));
    if (d_miss_records_) cudaFree(reinterpret_cast<void*>(d_miss_records_));
    if (d_hitgroup_records_)
      cudaFree(reinterpret_cast<void*>(d_hitgroup_records_));

    if (pipeline_) optixPipelineDestroy(pipeline_);
    for (auto pg : program_groups_) {
      if (pg) optixProgramGroupDestroy(pg);
    }
    if (module_) optixModuleDestroy(module_);
    if (context_) optixDeviceContextDestroy(context_);
  }

  OptiXContext(const OptiXContext&) = delete;
  OptiXContext& operator=(const OptiXContext&) = delete;

  void initialize() {
    // Initialize OptiX
    OPTIX_CHECK(optixInit());

    // Create context on current CUDA device
    CUcontext cu_ctx = nullptr;
    OptixDeviceContextOptions ctx_options = {};
    ctx_options.logCallbackFunction = nullptr;
    ctx_options.logCallbackLevel = 0;
    OPTIX_CHECK(optixDeviceContextCreate(cu_ctx, &ctx_options, &context_));

    create_module();
    create_program_groups();
    create_pipeline();
    create_sbt();

    // Register destroy callback for CPU bvh_destroy to call
    g_scene_destroy = [](int64_t handle) {
      // Negative handles are OptiX; negate to get positive registry key
      OptiXContext::instance().unregister_gas(-handle);
    };
  }

  void create_module() {
    OptixModuleCompileOptions module_options = {};
    module_options.maxRegisterCount = OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT;
    module_options.optLevel = OPTIX_COMPILE_OPTIMIZATION_DEFAULT;
    module_options.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_NONE;

    pipeline_compile_options_ = {};
    pipeline_compile_options_.usesMotionBlur = false;
    pipeline_compile_options_.traversableGraphFlags =
        OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS;
    pipeline_compile_options_.numPayloadValues = 6;
    pipeline_compile_options_.numAttributeValues = 2;  // barycentrics
    pipeline_compile_options_.pipelineLaunchParamsVariableName = "params";

    char log[2048];
    size_t log_size = sizeof(log);

#if OPTIX_VERSION >= 70700
    OPTIX_CHECK(optixModuleCreate(
        context_, &module_options, &pipeline_compile_options_,
        torchscience_optix_programs_ptx,
        strlen(torchscience_optix_programs_ptx), log, &log_size, &module_));
#else
    OPTIX_CHECK(optixModuleCreateFromPTX(
        context_, &module_options, &pipeline_compile_options_,
        torchscience_optix_programs_ptx,
        strlen(torchscience_optix_programs_ptx), log, &log_size, &module_));
#endif
  }

  void create_program_groups() {
    program_groups_.resize(4);
    char log[2048];
    size_t log_size;

    // Raygen program group
    {
      OptixProgramGroupDesc desc = {};
      desc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;
      desc.raygen.module = module_;
      desc.raygen.entryFunctionName = "__raygen__rg";
      OptixProgramGroupOptions options = {};
      log_size = sizeof(log);
      OPTIX_CHECK(optixProgramGroupCreate(
          context_, &desc, 1, &options, log, &log_size,
          &program_groups_[PG_RAYGEN]));
    }

    // Miss program groups
    {
      OptixProgramGroupDesc desc = {};
      desc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
      desc.miss.module = module_;
      desc.miss.entryFunctionName = "__miss__radiance";
      OptixProgramGroupOptions options = {};
      log_size = sizeof(log);
      OPTIX_CHECK(optixProgramGroupCreate(
          context_, &desc, 1, &options, log, &log_size,
          &program_groups_[PG_MISS_RADIANCE]));
    }
    {
      OptixProgramGroupDesc desc = {};
      desc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
      desc.miss.module = module_;
      desc.miss.entryFunctionName = "__miss__shadow";
      OptixProgramGroupOptions options = {};
      log_size = sizeof(log);
      OPTIX_CHECK(optixProgramGroupCreate(
          context_, &desc, 1, &options, log, &log_size,
          &program_groups_[PG_MISS_SHADOW]));
    }

    // Hit group: closesthit for radiance rays
    {
      OptixProgramGroupDesc desc = {};
      desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
      desc.hitgroup.moduleCH = module_;
      desc.hitgroup.entryFunctionNameCH = "__closesthit__radiance";
      desc.hitgroup.moduleAH = nullptr;
      desc.hitgroup.entryFunctionNameAH = nullptr;
      OptixProgramGroupOptions options = {};
      log_size = sizeof(log);
      OPTIX_CHECK(optixProgramGroupCreate(
          context_, &desc, 1, &options, log, &log_size,
          &program_groups_[PG_HITGROUP_RADIANCE]));
    }

    // We don't need a separate shadow hit group because we use
    // OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT | OPTIX_RAY_FLAG_DISABLE_CLOSESTHIT
    // in the raygen program, which handles occlusion without a hit program.
    // The miss program sets occluded=false, and the built-in anyhit
    // (default accept) combined with the terminate flag handles occluded=true
    // via the raygen detecting that the ray was not a miss.
    // Actually, we do need a shadow hit group for proper SBT layout:
  }

  void create_pipeline() {
    OptixPipelineLinkOptions link_options = {};
    link_options.maxTraceDepth = 1;

    char log[2048];
    size_t log_size = sizeof(log);

    OPTIX_CHECK(optixPipelineCreate(
        context_, &pipeline_compile_options_, &link_options,
        program_groups_.data(),
        static_cast<unsigned int>(program_groups_.size()), log, &log_size,
        &pipeline_));

    // Set stack sizes
    OptixStackSizes stack_sizes = {};
    for (auto pg : program_groups_) {
      OPTIX_CHECK(optixUtilAccumulateStackSizes(pg, &stack_sizes, pipeline_));
    }

    uint32_t direct_callable_stack = 0;
    uint32_t continuation_stack = 0;
    uint32_t max_traversal_depth = 1;

    OPTIX_CHECK(optixUtilComputeStackSizes(
        &stack_sizes, max_traversal_depth, direct_callable_stack,
        continuation_stack, &direct_callable_stack, &continuation_stack,
        &continuation_stack));

    OPTIX_CHECK(
        optixPipelineSetStackSize(pipeline_, direct_callable_stack,
                                  continuation_stack, continuation_stack,
                                  max_traversal_depth));
  }

  void create_sbt() {
    // Raygen record
    {
      RaygenRecord rec = {};
      OPTIX_CHECK(optixSbtRecordPackHeader(
          program_groups_[PG_RAYGEN], &rec));
      CUDA_CHECK(cudaMalloc(
          reinterpret_cast<void**>(&d_raygen_record_), sizeof(RaygenRecord)));
      CUDA_CHECK(cudaMemcpy(
          reinterpret_cast<void*>(d_raygen_record_), &rec,
          sizeof(RaygenRecord), cudaMemcpyHostToDevice));
    }

    // Miss records (radiance, shadow)
    {
      MissRecord miss_records[RAY_TYPE_COUNT] = {};
      OPTIX_CHECK(optixSbtRecordPackHeader(
          program_groups_[PG_MISS_RADIANCE], &miss_records[RAY_TYPE_RADIANCE]));
      OPTIX_CHECK(optixSbtRecordPackHeader(
          program_groups_[PG_MISS_SHADOW], &miss_records[RAY_TYPE_SHADOW]));

      CUDA_CHECK(cudaMalloc(
          reinterpret_cast<void**>(&d_miss_records_),
          sizeof(MissRecord) * RAY_TYPE_COUNT));
      CUDA_CHECK(cudaMemcpy(
          reinterpret_cast<void*>(d_miss_records_), miss_records,
          sizeof(MissRecord) * RAY_TYPE_COUNT, cudaMemcpyHostToDevice));
    }

    // Hit group records (radiance only - shadow uses ray flags)
    // We need RAY_TYPE_COUNT hit group records per geometry.
    // For radiance (type 0): closesthit
    // For shadow (type 1): use the same radiance hit group (won't be called
    //   due to DISABLE_CLOSESTHIT flag, but SBT slot must exist)
    {
      HitGroupRecord hitgroup_records[RAY_TYPE_COUNT] = {};
      OPTIX_CHECK(optixSbtRecordPackHeader(
          program_groups_[PG_HITGROUP_RADIANCE],
          &hitgroup_records[RAY_TYPE_RADIANCE]));
      // Shadow slot: pack same header (it won't be called due to ray flags)
      OPTIX_CHECK(optixSbtRecordPackHeader(
          program_groups_[PG_HITGROUP_RADIANCE],
          &hitgroup_records[RAY_TYPE_SHADOW]));

      CUDA_CHECK(cudaMalloc(
          reinterpret_cast<void**>(&d_hitgroup_records_),
          sizeof(HitGroupRecord) * RAY_TYPE_COUNT));
      CUDA_CHECK(cudaMemcpy(
          reinterpret_cast<void*>(d_hitgroup_records_), hitgroup_records,
          sizeof(HitGroupRecord) * RAY_TYPE_COUNT, cudaMemcpyHostToDevice));
    }

    // Build SBT
    sbt_ = {};
    sbt_.raygenRecord = d_raygen_record_;
    sbt_.missRecordBase = d_miss_records_;
    sbt_.missRecordStrideInBytes = sizeof(MissRecord);
    sbt_.missRecordCount = RAY_TYPE_COUNT;
    sbt_.hitgroupRecordBase = d_hitgroup_records_;
    sbt_.hitgroupRecordStrideInBytes = sizeof(HitGroupRecord);
    sbt_.hitgroupRecordCount = RAY_TYPE_COUNT;
  }

  // Program group indices
  enum {
    PG_RAYGEN = 0,
    PG_MISS_RADIANCE = 1,
    PG_MISS_SHADOW = 2,
    PG_HITGROUP_RADIANCE = 3
  };

  OptixDeviceContext context_ = nullptr;
  OptixModule module_ = nullptr;
  OptixPipelineCompileOptions pipeline_compile_options_ = {};
  std::vector<OptixProgramGroup> program_groups_;
  OptixPipeline pipeline_ = nullptr;
  OptixShaderBindingTable sbt_ = {};

  CUdeviceptr d_raygen_record_ = 0;
  CUdeviceptr d_miss_records_ = 0;
  CUdeviceptr d_hitgroup_records_ = 0;

  // Scene registry
  mutable std::mutex registry_mutex_;
  std::unordered_map<int64_t, GASResources> scenes_;
  int64_t next_handle_ = 1;
};

}  // namespace torchscience::optix

#endif  // TORCHSCIENCE_OPTIX
